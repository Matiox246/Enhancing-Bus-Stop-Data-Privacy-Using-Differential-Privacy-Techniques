<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lossless Image Zoom</title>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
    }
    canvas {
      border: 2px solid #555;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    button {
      margin-right: 5px;
      padding: 5px 10px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="resetZoom">Reset</button>
  </div>
  <canvas id="zoomCanvas"></canvas>
  
  <script>
    const canvas = document.getElementById("zoomCanvas");
    const ctx = canvas.getContext("2d");
    const resetBtn = document.getElementById("resetZoom");

    // Image and Canvas Setup
    const image = new Image();
    image.src = "vancouver_bus_tree.jpeg"; // Replace with a high-resolution image
    canvas.width = window.innerWidth * 0.9;
    canvas.height = window.innerHeight * 0.9;

    let scale = 1;
    let position = { x: 0, y: 0 }; // Translation for panning
    let startDragOffset = { x: 0, y: 0 };
    let isDragging = false;

    image.onload = () => {
      // Draw the initial image
      drawImage();
    };

    function drawImage() {
      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Render the image at the current scale and position
      const dx = position.x + canvas.width / 2 - (image.width * scale) / 2;
      const dy = position.y + canvas.height / 2 - (image.height * scale) / 2;
      ctx.drawImage(image, dx, dy, image.width * scale, image.height * scale);
    }

    // Mouse Wheel for Zooming
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      
      // Get mouse position relative to the canvas
      const mouseX = e.offsetX;
      const mouseY = e.offsetY;

      // Determine zoom direction
      const zoomFactor = 1.2;
      const zoom = e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;

      // Update scale
      scale *= zoom;

      // Adjust position to keep the zoom centered at the mouse pointer
      position.x -= (mouseX - position.x) * (zoom - 1);
      position.y -= (mouseY - position.y) * (zoom - 1);

      // Limit scale to avoid too much zoom-out or zoom-in
      scale = Math.min(Math.max(scale, 0.5), 5);

      drawImage();
    });

    // Mouse Dragging for Panning
    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      startDragOffset.x = e.offsetX - position.x;
      startDragOffset.y = e.offsetY - position.y;
      canvas.style.cursor = "grabbing";
    });

    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        position.x = e.offsetX - startDragOffset.x;
        position.y = e.offsetY - startDragOffset.y;
        drawImage();
      }
    });

    canvas.addEventListener("mouseup", () => {
      isDragging = false;
      canvas.style.cursor = "grab";
    });

    canvas.addEventListener("mouseleave", () => {
      isDragging = false;
      canvas.style.cursor = "grab";
    });

    // Reset Zoom and Position
    resetBtn.addEventListener("click", () => {
      scale = 1;
      position = { x: 0, y: 0 };
      drawImage();
    });

    // Handle Window Resize
    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth * 0.9;
      canvas.height = window.innerHeight * 0.9;
      drawImage();
    });
  </script>
</body>
</html>
